#
# Copyright 2025 Adobe. All rights reserved.
# This file is licensed to you under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License. You may obtain a copy
# of the License at http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed under
# the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
# OF ANY KIND, either express or implied. See the License for the specific language
# governing permissions and limitations under the License.
#

name: (Reusable) Downmerge main -> dev

on:
  workflow_call:
    inputs:
      source-branch-name:
        description: 'Branch to merge from. Default is "main".'
        type: string
        default: 'main'
      
      target-branches:
        description: 'Space separated list of branches that should receive pull requests. Example: "dev dev-actions"'
        type: string
        default: 'dev'

      increment-target-branch:
        description: 'If true, automatically compute and create the next semver branch, where target-branches is interpreted as a list of prefixes. Example: "dev- dev-v" (dev-1.2.3, dev-v1.2.3 exist) → "dev-1.2.4 dev-v1.2.4"'
        type: boolean
        default: false

jobs:
  downmerge:
    runs-on: ubuntu-24.04
    permissions:
      contents: write
      pull-requests: write
    env:
      GH_TOKEN: ${{ github.token }}

    steps:
      - name: Check out repository
        uses: actions/checkout@v4.2.2
        with:
          ref: ${{ inputs.source-branch-name }}
          # Allows merging/pulling across branches
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Down-merge logic
        env:
          SOURCE: ${{ inputs.source-branch-name }}
          TARGETS: ${{ inputs.target-branches }}
          INCREMENT: ${{ inputs.increment-target-branch }}
        run: |
          set -e
          # If increment flag is set, treat TARGETS as list of prefixes and compute next semver branch for each
          if [ "$INCREMENT" = "true" ]; then
            echo "Increment mode enabled – will create next semver branch for each prefix in '$TARGETS'"
            NEW_TARGETS=""
            for prefix in $TARGETS; do
              echo "Processing prefix: $prefix"
              # find latest branch with this prefix
              latest=$(git ls-remote --heads origin "refs/heads/${prefix}*" | awk '{print $2}' | sed -E "s#refs/heads/${prefix}##" | sort -t'.' -k1,1V -k2,2V -k3,3V | tail -n1)
              if [ -z "$latest" ]; then
                echo "No existing branches found for prefix '$prefix'; skipping."
                continue
              fi
              IFS='.' read -r major minor patch <<< "$latest"
              patch=$((patch+1))
              new_branch="${prefix}${major}.${minor}.${patch}"
              echo "Next branch for prefix '$prefix' will be $new_branch"
              NEW_TARGETS="$NEW_TARGETS $new_branch"
            done
            TARGETS=$(echo "$NEW_TARGETS" | xargs) # trim whitespace
            if [ -z "$TARGETS" ]; then
              echo "No new branches were generated. Exiting workflow."
              exit 0
            fi
            echo "Computed TARGETS: $TARGETS"
          fi

          for base in $TARGETS; do
            if ! git ls-remote --heads origin "$base" | grep -q "$base"; then
              if [ "$INCREMENT" = "true" ]; then
                echo "Creating new branch '$base' from '$SOURCE' (increment mode)"
                git checkout "$SOURCE"
                git checkout -b "$base"
                git push origin "$base"
                continue
              else
                echo "Target branch '$base' does not exist and increment mode is off – skipping."
                continue
              fi
            fi
            # PR workflow (branch exists)
            echo "Creating PR from $SOURCE into $base"
            # skip if open PR already exists
            if gh pr list --base "$base" --head "$SOURCE" --state open --json number -q '.[0]' | grep -q '[0-9]'; then
              echo "PR already exists for $base – skipping."
              continue
            fi
            gh pr create \
              --base "$base" \
              --head "$SOURCE" \
              --title "Downmerge `$SOURCE` -> `$base`" \
              --body "Automatically bringing changes from `$SOURCE` into `$base`." || true
          done
